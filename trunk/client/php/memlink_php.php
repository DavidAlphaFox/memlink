<?php

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.39
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

// Try to load our extension if it's not already loaded.
if (!extension_loaded("memlink")) {
  if (strtolower(substr(PHP_OS, 0, 3)) === 'win') {
    if (!dl('php_memlink.dll')) return;
  } else {
    // PHP_SHLIB_SUFFIX gives 'dylib' on MacOS X but modules are 'so'.
    if (PHP_SHLIB_SUFFIX === 'dylib') {
      if (!dl('memlink.so')) return;
    } else {
      if (!dl('memlink.'.PHP_SHLIB_SUFFIX)) return;
    }
  }
}



/*abstract class memlink {
	const MEMLINK_READER = MEMLINK_READER;

	const MEMLINK_WRITER = MEMLINK_WRITER;

	const MEMLINK_ALL = MEMLINK_ALL;

	const MEMLINK_ERR_TIMEOUT = MEMLINK_ERR_TIMEOUT;

	const MEMLINK_ERR_SEND = MEMLINK_ERR_SEND;

	const MEMLINK_ERR_RECV = MEMLINK_ERR_RECV;

	const MEMLINK_ERR_CLIENT = MEMLINK_ERR_CLIENT;

	const MEMLINK_ERR_SERVER = MEMLINK_ERR_SERVER;

	const MEMLINK_ERR_SERVER_TEMP = MEMLINK_ERR_SERVER_TEMP;

	const MEMLINK_ERR_CLIENT_CMD = MEMLINK_ERR_CLIENT_CMD;

	const MEMLINK_ERR_NOKEY = MEMLINK_ERR_NOKEY;

	const MEMLINK_ERR_EKEY = MEMLINK_ERR_EKEY;

	const MEMLINK_ERR_CONNECT = MEMLINK_ERR_CONNECT;

	const MEMLINK_ERR_RETCODE = MEMLINK_ERR_RETCODE;

	const MEMLINK_ERR = MEMLINK_ERR;

	const MEMLINK_OK = MEMLINK_OK;

	static function memlink_result_free($result) {
		memlink_result_free($result);
	}

	static function memlink_create($host,$readport,$writeport,$timeout) {
		$r=memlink_create($host,$readport,$writeport,$timeout);
		return is_resource($r) ? new MemLink($r) : $r;
	}

	static function memlink_destroy($m) {
		memlink_destroy($m);
	}

	static function memlink_close($m) {
		memlink_close($m);
	}

	static function memlink_cmd_dump($m) {
		return memlink_cmd_dump($m);
	}

	static function memlink_cmd_clean($m,$key) {
		return memlink_cmd_clean($m,$key);
	}

	static function memlink_cmd_stat($m,$key,$stat) {
		return memlink_cmd_stat($m,$key,$stat);
	}

	static function memlink_cmd_create($m,$key,$valuelen,$maskstr) {
		return memlink_cmd_create($m,$key,$valuelen,$maskstr);
	}

	static function memlink_cmd_del($m,$key,$value,$valuelen) {
		return memlink_cmd_del($m,$key,$value,$valuelen);
	}

	static function memlink_cmd_insert($m,$key,$value,$valuelen,$maskstr,$pos) {
		return memlink_cmd_insert($m,$key,$value,$valuelen,$maskstr,$pos);
	}

	static function memlink_cmd_update($m,$key,$value,$valuelen,$pos) {
		return memlink_cmd_update($m,$key,$value,$valuelen,$pos);
	}

	static function memlink_cmd_mask($m,$key,$value,$valuelen,$maskstr) {
		return memlink_cmd_mask($m,$key,$value,$valuelen,$maskstr);
	}

	static function memlink_cmd_tag($m,$key,$value,$valuelen,$tag) {
		return memlink_cmd_tag($m,$key,$value,$valuelen,$tag);
	}

	static function memlink_cmd_range($m,$key,$maskstr,$frompos,$len,$result) {
		return memlink_cmd_range($m,$key,$maskstr,$frompos,$len,$result);
	}
}
*/

/* PHP Proxy Classes */
class MemLink {
	public $_cPtr=null;

	function __set($var,$value) {
		$func = 'MemLink_'.$var.'_set';
		if (function_exists($func)) call_user_func($func,$this->_cPtr,$value);
	}

	function __isset($var) {
		return function_exists('MemLink_'.$var.'_set');
	}

	function __get($var) {
		$func = 'MemLink_'.$var.'_get';
		if (function_exists($func)) return call_user_func($func,$this->_cPtr);
		return null;
	}

	function __construct() {
		$this->_cPtr=new_MemLink();
	}
}


class MemLinkStat {
	public $_cPtr=null;

	function __set($var,$value) {
		$func = 'MemLinkStat_'.$var.'_set';
		if (function_exists($func)) call_user_func($func,$this->_cPtr,$value);
	}

	function __isset($var) {
		return function_exists('MemLinkStat_'.$var.'_set');
	}

	function __get($var) {
		$func = 'MemLinkStat_'.$var.'_get';
		if (function_exists($func)) return call_user_func($func,$this->_cPtr);
		return null;
	}

	function __construct() {
		$this->_cPtr=new_MemLinkStat();
	}
}

class MemLinkItem {
	public $_cPtr=null;

	function __set($var,$value) {
		$func = 'MemLinkItem_'.$var.'_set';
		if (function_exists($func)) call_user_func($func,$this->_cPtr,$value);
	}

	function __isset($var) {
		return function_exists('MemLinkItem_'.$var.'_set');
	}

	function __get($var) {
		$func = 'MemLinkItem_'.$var.'_get';
		if (function_exists($func)) return call_user_func($func,$this->_cPtr);
		return null;
	}

	function __construct() {
		$this->_cPtr=new_MemLinkItem();
	}
}

class MemLinkResult {
	public $_cPtr=null;

	function __set($var,$value) {
		$func = 'MemLinkResult_'.$var.'_set';
		if (function_exists($func)) call_user_func($func,$this->_cPtr,$value);
	}

	function __isset($var) {
		return function_exists('MemLinkResult_'.$var.'_set');
	}

	function __get($var) {
		$func = 'MemLinkResult_'.$var.'_get';
		if (function_exists($func)) return call_user_func($func,$this->_cPtr);
		return null;
	}

	function __construct() {
		$this->_cPtr=new_MemLinkResult();
	}

    function __destruct() {
        memlink_result_free($this->_cPtr);
    }
}


?>
