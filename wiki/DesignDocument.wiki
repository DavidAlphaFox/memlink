#summary MemLink详细设计文档

= 1 工作方式 =

!MemLink是一个独立的服务程序，类似于memcached，不同的是它并不是提供key-value数据的存储，而是在内存中存储的是列表数据。


= 2 具体结构 =

这里我们借用了memcached的网络框架，在他的基础上来增加我们想要的列表功能。见下图：

XXX

在网络处理部分，我们使用memcached的代码。他是专门用一个线程来接受连接，然后把连接给各个处理线程。我们自己的列表功能就体现在处理线程里面。这里每个列表项都有一个名字，也就是一个唯一的列表名字对应一个列表数据，我们使用hash来存储。列表数据部分（图中红色框部分）是我们真实的数据存储结构。任何的对列表数据的写操作都必须要获得写锁，写操作和dump的操作不能同时进行。

== 线程工作方式 ==

目前，一共有4种线程。分别为读线程，写线程，同步线程，dump线程。读线程是可以有多个的。其他的线程都只有一个。写线程用来完成数据的修改，同步线程专门用来主从同步。Dump线程用来dump数据到硬盘。写线程和同步线程分别对应有一个网络事件处理机制来接受网络连接，需要监听独立的端口，他们的处理操作由网络请求来触发。而dump线程由时间来触发，动态产生一个线程来处理。

== Hash ==

图中的蓝色框部分为hash表的数据结构。Hash采用的是链表法。Hash的数据节点包含4个数据，在图中是 key,  used,  all count, data。其中key为列表名，used为该列表实际消耗了多少存储（这里是计算数据块的使用情况，比如总共可以存储数据1000个，使用了342个，那么就是342），all count为实际分配了多少存储，data为实际数据的指针。

== 数据存储 ==

红色框为我们列表实际的数据结构。我们并不是每次为1个数据分配一块内存，然后链接起来。而是每次分配一定数据量的连续块（假设我们每次分配100块的连续数据，实际上我们可以配置的）。同时，在这一个连续块中还有两个额外的数据，分别为“已经使用非标记删除的数量（无符号2字节短整型）”和“指向下一个数据块的指针（指针）”。在每个内部的小数据区中，包括一个mask占用的空间和实际的数据占用的空间。Mask用来标示数据的属性。 Mask中有一个保留位，用来表示标记删除或者标记恢复。

== 数据操作 ==

对数据块的操作，我们的原则是写操作尽量不影响读操作，这样就要避免数据块内的数据移动，取而代之的是拷贝数据到新的数据块。目前有以下几种涉及写的操作：

=== 插入一个数据 ===

如果是在列表的头部插入，那就是操作数据链中第一块，第一块内当前位置有空就可以插入，否则需要创建出一个新数据块，把数据写入其中最后一个位置，然后在作为头部链入数据链中。写入最后一个位置的目的是让下次插入头部就不需要再创建新数据块了。如下图：

XXX

如果是在数据链的中间插入，如果当前位置为空，那么直接插入数据。如果不为空，那么我们要新分配一个数据块，将当前要插入的数据块中的数据拷贝到新块，如果新数据块不能完全存储（因为插入了一个），那么就要再分配一个新数据块，把溢出的数据放到这个数据块中，然后链接入数据链。见下图：

XXX

由于有新的数据块替代了原来的数据块。原来的数据块要被释放掉，但不是马上释放，而是加入一个链表。此链表保存所有要示范班的数据块，当以后我们要新分配数据块的时候，我们就从里面取。

=== 删除一个数据 ===

删除数据只把数据所在的位置0，并且修改该数据块的“已使用数量”以及hash节点中的“总使用数量”

=== 修改一个数据的mask ===

Mask是数据的属性，直接修改即可。

=== Mask是数据的属性，直接修改即可 ===

修改位置实际上是删除数据，以及新插入数据到某个位置。

=== 读操作 ===

读操作，这里主要就是取列表中的某个范围的数据。还有一个mask条件。读操作分两种情况，一是mask为空，二是mask为其他值的读。如果为空，那么从每个数据块中的记录该块使用数量，可以很容易的计算出这个范围涉及到那几个数据块，直接到这几个数据块中读取就可以了。如果不是空就只能挨个判断，全部循环一遍，直到得到这个范围的数据。

== 数据存储空间的回收 ==

由于我们在删除数据的时候只是把那个位置给置0，所以会出现一些空间浪费。运行时间越长，空间的浪费就越严重。因此，我们需要在一定的时候对存储空间重排，让数据更加紧凑，以去除空间中的空洞。
触发这个动作的条件是，空间的利用率小于等于50%（这个值可以配置）。这个检测在每次写操作的时候进行。计算方法是hash节点中的 已使用存储数/分配的存储数 这个结果和50%来比较。一旦符合条件这个写操作完成后就马上进行空间的重排。但并不是一次性就把整个数据链全部重排，而是分批进行，一次进行100个数据块（这个值可以配置）。剩下的块由event调度，在下次事件循环的时候接着进行。
重排的方法是这样，我们分配出新的数据块，然后把老的100个全部拷贝到新的数据块中，完成后把数据链重新链起来。老的数据块重新链接到一个空闲链表中，等待下次分配后再使用。下图用两个数据块做了个简单说明：

XXX

== 数据dump ==

所有列表数据会定时dump一份到硬盘上。这个过程由一个线程来独立进行。在dump之前，需要在持有写锁，这样侯不允许同时还有写操作。Dump完成后要生成新的日志文件。流程如下图：

XXX


Dump文件名dump.dat。在dump过程中，并不直接dump到这个文件，而是dump到名为dump.dat.tmp的文件，当dump过程成功完成后，才把文件名改为dump.dat。
Dump文件的格式为二进制的格式：

||Dump格式版本号（2字节）||Dump文件版本号（4字节）||对应的log版本（4字节）||数据区长度（8字节）||数据区 ||


前2字节是dump格式版本号，无符号短整型，现在默认为1，每次格式变更才修改此值。Dump文件版本号在每次dump文件生成都要自增1后面4个字节为log日志版本，是个无符号整型。数据区长度为后面数据区占得字节数。数据区，是由所有的列表项紧挨着组成，其中一个列表项格式如下，整个数据区就是由N个列表项组成：

||Key长度（1字节）||Key||Value长度（1字节）||Mask长度（1字节）||Mask项数（1字节）||Mask格式（长度由mask项数决定）||Mask Value数量（4字节）||Value||Mask||

= 3 日志记录 =

= 6 命令编号 =

所有客户端命令以及同步命令，对应都有一个命令编号，如下：

||命令 ||编号||
||Dump ||1||
||Clean ||2||
||Stat ||3||
||Create ||4||
||Del ||5||
||Insert ||6||
||Update ||7||
||Mask ||8||
||Tag ||9||
||range ||10||
||Sync ||100||
||Syncontinue||101||


= 7 启动流程=

下面是server启动要执行的一些流程：

XXX



= 8 配置信息 =

程序应该可以配置项有如下几个

||名称||类型||描述||默认值||
||block_data_count||整型||数据块的容量||100||
||block_clean_cond||浮点数||数据重排条件||0.5||
||dump_interval||整型||Dump数据间隔时间，单位为分钟||60||
||write_port||整型||写线程占用端口||11212||
||sync_port||整型||同步线程占用端口||11213||
||data_dir||字符串||Dump和log数据文件目录||||
||log_level||整型||日志输出等级：0-3。 0：无日志 1：只输出错误 2：只输出错误和警告 3：只输出错误，警告和普通信息|| 3||
||timeout||整型|| || ||

